-- User CRUD API
-- A simple HTTP API for managing users with profiles, selected stores, and shopping lists

use lib.unison_cloud_27_2_0
use lib.unison_cloud_27_2_0.lib.unison_http_14_0_0
use lib.unison_routes_7_0_2
use lib.unison_json_1_3_5

-- ============================================================================
-- Type Definitions
-- ============================================================================

-- User profile settings
unique type UserProfile = {
  preferredLanguage : Text,
  currency : Text,
  notificationsEnabled : Boolean,
  darkModeEnabled : Boolean
}

-- A store selected by the user
unique type SelectedStore = {
  storeId : Nat,
  storeName : Text,
  addedAt : Text,
  isPreferred : Boolean
}

-- An item in a shopping list
unique type ShoppingItem = {
  itemId : Text,
  itemName : Text,
  quantity : Nat,
  unit : Text,
  category : Text,
  isChecked : Boolean,
  notes : Optional Text
}

-- A shopping list
unique type ShoppingList = {
  listId : Text,
  listName : Text,
  createdAt : Text,
  updatedAt : Text,
  isArchived : Boolean,
  items : [ShoppingItem]
}

-- The main User type
unique type User = {
  id : Text,
  name : Text,
  email : Text,
  avatarUrl : Text,
  createdAt : Text,
  profile : UserProfile,
  selectedStores : [SelectedStore],
  shoppingLists : [ShoppingList]
}

-- UserId for key lookups
unique type UserId = UserId Text

UserId.toText : UserId -> Text
UserId.toText = cases UserId t -> t

-- ============================================================================
-- JSON Encoders
-- ============================================================================

UserProfile.toJson : UserProfile -> Json
UserProfile.toJson p =
  use Json.object
  empty
    |> addText "preferredLanguage" (UserProfile.preferredLanguage p)
    |> addText "currency" (UserProfile.currency p)
    |> addBoolean "notificationsEnabled" (UserProfile.notificationsEnabled p)
    |> addBoolean "darkModeEnabled" (UserProfile.darkModeEnabled p)

SelectedStore.toJson : SelectedStore -> Json
SelectedStore.toJson ss =
  use Json.object
  empty
    |> addNat "storeId" (SelectedStore.storeId ss)
    |> addText "storeName" (SelectedStore.storeName ss)
    |> addText "addedAt" (SelectedStore.addedAt ss)
    |> addBoolean "isPreferred" (SelectedStore.isPreferred ss)

ShoppingItem.toJson : ShoppingItem -> Json
ShoppingItem.toJson item =
  use Json.object
  base =
    empty
      |> addText "id" (ShoppingItem.itemId item)
      |> addText "name" (ShoppingItem.itemName item)
      |> addNat "quantity" (ShoppingItem.quantity item)
      |> addText "unit" (ShoppingItem.unit item)
      |> addText "category" (ShoppingItem.category item)
      |> addBoolean "isChecked" (ShoppingItem.isChecked item)
  match ShoppingItem.notes item with
    Some n -> base |> addText "notes" n
    None -> base |> add "notes" Json.null

ShoppingList.toJson : ShoppingList -> Json
ShoppingList.toJson sl =
  use Json.object
  empty
    |> addText "id" (ShoppingList.listId sl)
    |> addText "name" (ShoppingList.listName sl)
    |> addText "createdAt" (ShoppingList.createdAt sl)
    |> addText "updatedAt" (ShoppingList.updatedAt sl)
    |> addBoolean "isArchived" (ShoppingList.isArchived sl)
    |> add "items" (Json.array (List.map ShoppingItem.toJson (ShoppingList.items sl)))

User.toJson : User -> Json
User.toJson user =
  use Json.object
  empty
    |> addText "id" (User.id user)
    |> addText "name" (User.name user)
    |> addText "email" (User.email user)
    |> addText "avatarUrl" (User.avatarUrl user)
    |> addText "createdAt" (User.createdAt user)
    |> add "profile" (UserProfile.toJson (User.profile user))
    |> add "selectedStores" (Json.array (List.map SelectedStore.toJson (User.selectedStores user)))
    |> add "shoppingLists" (Json.array (List.map ShoppingList.toJson (User.shoppingLists user)))

-- ============================================================================
-- JSON Decoders
-- ============================================================================

UserProfile.decoder : '{Decoder} UserProfile
UserProfile.decoder = do
  use Decoder.object at!
  preferredLanguage = at! "preferredLanguage" Decoder.text
  currency = at! "currency" Decoder.text
  notificationsEnabled = at! "notificationsEnabled" Decoder.boolean
  darkModeEnabled = at! "darkModeEnabled" Decoder.boolean
  UserProfile preferredLanguage currency notificationsEnabled darkModeEnabled

SelectedStore.decoder : '{Decoder} SelectedStore
SelectedStore.decoder = do
  use Decoder.object at!
  storeId = at! "storeId" Decoder.nat
  storeName = at! "storeName" Decoder.text
  addedAt = at! "addedAt" Decoder.text
  isPreferred = at! "isPreferred" Decoder.boolean
  SelectedStore storeId storeName addedAt isPreferred

ShoppingItem.decoder : '{Decoder} ShoppingItem
ShoppingItem.decoder = do
  use Decoder.object at! optionalAt!
  id = at! "id" Decoder.text
  name = at! "name" Decoder.text
  quantity = at! "quantity" Decoder.nat
  unit = at! "unit" Decoder.text
  category = at! "category" Decoder.text
  isChecked = at! "isChecked" Decoder.boolean
  notes = optionalAt! "notes" Decoder.text
  ShoppingItem id name quantity unit category isChecked notes

ShoppingList.decoder : '{Decoder} ShoppingList
ShoppingList.decoder = do
  use Decoder.object at!
  id = at! "id" Decoder.text
  name = at! "name" Decoder.text
  createdAt = at! "createdAt" Decoder.text
  updatedAt = at! "updatedAt" Decoder.text
  isArchived = at! "isArchived" Decoder.boolean
  items = at! "items" (Decoder.array ShoppingItem.decoder)
  ShoppingList id name createdAt updatedAt isArchived items

User.decoder : '{Decoder} User
User.decoder = do
  use Decoder.object at!
  id = at! "id" Decoder.text
  name = at! "name" Decoder.text
  email = at! "email" Decoder.text
  avatarUrl = at! "avatarUrl" Decoder.text
  createdAt = at! "createdAt" Decoder.text
  profile = at! "profile" UserProfile.decoder
  selectedStores = at! "selectedStores" (Decoder.array SelectedStore.decoder)
  shoppingLists = at! "shoppingLists" (Decoder.array ShoppingList.decoder)
  User id name email avatarUrl createdAt profile selectedStores shoppingLists

-- ============================================================================
-- Storage Ability
-- ============================================================================

ability UserStorage where
  getUser : UserId ->{UserStorage} Optional User
  upsertUser : User ->{UserStorage} ()
  deleteUser : UserId ->{UserStorage} ()
  getAllUsers : '{UserStorage} [User]

-- Handler implementation using OrderedTable
UserStorage.run : Database -> '{g, UserStorage} a ->{g, Remote} a
UserStorage.run db computation =
  table : OrderedTable Text User
  table = OrderedTable.named db "users" Universal.ordering

  go : Request {UserStorage} a ->{g, Remote} a
  go = cases
    { a } -> a
    { UserStorage.getUser (UserId userId) -> resume } ->
      result = OrderedTable.tryRead table userId
      handle resume result with go
    { UserStorage.upsertUser user -> resume } ->
      OrderedTable.write table (User.id user) user
      handle resume () with go
    { UserStorage.deleteUser (UserId userId) -> resume } ->
      OrderedTable.delete table userId
      handle resume () with go
    { UserStorage.getAllUsers () -> resume } ->
      users = Stream.toList (OrderedTable.toStream table) |> List.map (Tuple.at2)
      handle resume users with go

  handle computation() with go

-- ============================================================================
-- HTTP Routes
-- ============================================================================

users.routes : '{Route, Exception, UserStorage, Log} ()
users.routes =
  use Parser /
  use Text ++
  use Route <|>

  -- Health check
  health = do
    noCapture GET (s "health")
    ok.text "ok"

  -- GET /users - Get all users
  getAllUsers = do
    noCapture GET (s "users")
    info "Getting all users" []
    users = UserStorage.getAllUsers()
    json = Json.array (List.map User.toJson users)
    ok.json json

  -- GET /users/<id> - Get user by ID
  getUserById = do
    userId = route GET (s "users" / Parser.text)
    info "Getting user" [("id", userId)]
    match UserStorage.getUser (UserId userId) with
      Some user -> ok.json (User.toJson user)
      None -> notFound.text ("User not found: " ++ userId)

  -- POST /users - Create a new user
  createUser = do
    noCapture POST (s "users")
    user = decodeJson User.decoder
    info "Creating user" [("id", User.id user)]
    UserStorage.upsertUser user
    setStatus (Status 201 "Created")
    ok.json (User.toJson user)

  -- PUT /users/<id> - Update a user
  updateUser = do
    userId = route PUT (s "users" / Parser.text)
    user = decodeJson User.decoder
    info "Updating user" [("id", userId)]
    match UserStorage.getUser (UserId userId) with
      Some _ ->
        updatedUser = User userId (User.name user) (User.email user) (User.avatarUrl user) (User.createdAt user) (User.profile user) (User.selectedStores user) (User.shoppingLists user)
        UserStorage.upsertUser updatedUser
        ok.json (User.toJson updatedUser)
      None -> notFound.text ("User not found: " ++ userId)

  -- DELETE /users/<id> - Delete a user
  deleteUser = do
    userId = route DELETE (s "users" / Parser.text)
    info "Deleting user" [("id", userId)]
    match UserStorage.getUser (UserId userId) with
      Some _ ->
        UserStorage.deleteUser (UserId userId)
        ok.text "Deleted"
      None -> notFound.text ("User not found: " ++ userId)

  health <|> getAllUsers <|> getUserById <|> createUser <|> updateUser <|> deleteUser

-- ============================================================================
-- Main Entry Points
-- ============================================================================

users.main : Database -> HttpRequest ->{Exception, Storage, Remote, Log} HttpResponse
users.main db req = UserStorage.run db do Route.run users.routes req

-- Add CORS headers to a response
users.addCorsHeaders : HttpResponse -> HttpResponse
users.addCorsHeaders response =
  response
    |> HttpResponse.addHeader "Access-Control-Allow-Origin" "*"
    |> HttpResponse.addHeader "Access-Control-Allow-Methods" "GET, POST, PUT, DELETE, OPTIONS"
    |> HttpResponse.addHeader "Access-Control-Allow-Headers" "Content-Type, Authorization"

-- Check if request is OPTIONS method
users.isOptionsMethod : HttpRequest -> Boolean
users.isOptionsMethod req =
  match HttpRequest.method req with
    OPTIONS -> true
    _ -> false

-- CORS-enabled main entry point
users.mainWithCors : Database -> HttpRequest ->{Exception, Storage, Remote, Log} HttpResponse
users.mainWithCors db req =
  if users.isOptionsMethod req then
    users.addCorsHeaders (HttpResponse.ok Body.empty)
  else users.addCorsHeaders (users.main db req)

-- ============================================================================
-- Deployment
-- ============================================================================

-- Local deployment
users.deployLocal : '{IO, Exception} URI
users.deployLocal = main.local.serve do
  env = Environment.default()
  db = Database.named "users-db"
  Database.assign db env
  hash = deployHttp env (users.mainWithCors db)
  name = ServiceName.named "users-api"
  ServiceName.assign name hash

-- Cloud deployment
users.deployCloud : '{IO, Exception} ServiceHash HttpRequest HttpResponse
users.deployCloud = Cloud.main do
  env = Environment.default()
  db = Database.named "users-db"
  Database.assign db env
  hash = deployHttp env (users.mainWithCors db)
  name = ServiceName.named "users-api"
  _ = ServiceName.assign name hash
  hash